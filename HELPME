sudo su
mount -o remount, rw /


Bonjour Antoine,

Content que vous vous piquiez d'int√©r√™t pour la version "vrai mat√©riel" du sujet. üôÇ

J'avais demand√© aux √©l√®ves de se procurer ce mod√®le, √† l'√©poque, qui me semble
sensiblement identique au v√¥tre:
https://www.amazon.fr/gp/product/B0716T7R1Y/ref=ppx_yo_dt_b_asin_title_o00_s00?ie=UTF8&psc=1
Je suppose que vous l'avez branch√© et puis test√© avec la lib Python comme d√©crit
dans ce tuto, que j'avais utilis√© comme r√©f√©rence:
https://raspberry-lab.fr/Composants/Module-RFID-RC522-Raspberry-Francais/

Donc l√†, ce qui se passe, c'est que vous utilisez implicitement un module kernel
appel√© spidev (drivers/spi/spidev.c dans les sources de Linux), qui expose par un
noeud dans le devfs, votre MFRC522. Le driver se contente, via read(), write() et
consorts, de faire un passe-plat avec le device: en fait il ne contient aucune logique
propre, c'est vraiment un tuyau vers le userspace. Vous allez le court-circuiter et prendre
en charge le device vous-m√™mes.

Au niveau du device tree, il faudra indiquer que le device SPI associ√©, sous le noeud du
contr√¥leur SPI BCM2835 de la Raspberry Pi, est d√©sormais "compatible" avec votre
driver. On peut faire √ßa avec des "overlays" avec Raspbian; voici un exemple de ce que
Matthieu Moatti et Mathis Raguin m'avaient fait l'ann√©e derni√®re (ils ont pas chang√© le
nom des noeuds donc ils s'appellent encore "spidev", mais leur driver s'appelle bien "mmm"):

/dts-v1/;
/plugin/;

/ {
   compatible = "brcm,bcm2835";

   fragment@0 {
     target = <&spi>;

     __overlay__ {
       #address-cells = <1>;
       #size-cells = <0>;
       status = "okay";
       spidev@0 {
         spi-max-frequency = <500000>;
         reg = <0>;
         compatible = "mmm";
       };
       spidev@1 {
         spi-max-frequency = <500000>;
         reg = <1>;
         compatible = "mmm";
       };
     };
   };
};

La doc' officielle Raspbian est plut√¥t claire sur la fa√ßon de mettre en oeuvre cette
technique, qui permet de changer un device tree √† la vol√©e. Ca vous √©vite de tout
recompiler et r√©-√©crire la carte SD:
https://www.raspberrypi.org/documentation/configuration/device-tree.md

Maintenant, c√¥t√© driver. Pour r√©utiliser la base d√©velopp√©e pendant le projet, il va
falloir arr√™ter de "taper" dans l'√©mulateur. D√©barrassez-vous des headers que je vous
avais fait utiliser, et trouvez le device via le device tree comme vous savez maintenant
le faire. Ensuite, √ßa devient plus int√©ressant: l'API regmap que je vous fait utiliser
directement dans le sujet, a en fait √©t√© "pr√©par√©e" par moi. Normalement, elle demande
de sp√©cifier quel type de bus on va utiliser (SPI ou I2C), quels registres sont accessibles
en lecture et/ou √©criture, etc. Si vous lisez le code de mon mini-√©mulateur, vous verrez
que c'est ce que je fais, sauf que je "triche" en ne reliant jamais √† un vrai device.
Vous allez devoir faire vous-m√™mes ce travail d'adaptation.

L'ann√©e derni√®re, je ne connaissais pas regmap et faisais √©crire un driver via l'API
SPI "vanilla" du kernel; qui marche, mais regmap en simplifie l'usage. A vous de voir
ce que vous pr√©f√©rez: tout jeter et utiliser l'API SPI, ou garder un maximum de code
mais initialiser le driver de fa√ßon √† pr√©parer vous-m√™mes la regmap.

Pour info, je n'ai pas encore essay√© de le faire moi-m√™me. √âvidemment, trouver le
bon √©quilibre entre une version "soft" et une "hard" me permettrait de proposer √† vos
successeurs un sujet flexible, et plus mature; mais d'ici-l√†, vous serez devant moi.

A+,

--
Geoffrey
